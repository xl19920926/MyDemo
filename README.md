# 尚品汇项目
## 项目技术栈
vue + vuex + vue-router + vue-cli
## 使用到的第三方插件
nprogress 加载进度条
swiper  轮播图
element-plus  vue的ui库
mockjs  前端模拟后端数据
qrcode  二维码生成
less  css预处理器
less-loader  less编译器
vue-lazyload  图片懒加载

## 项目结构
node_modules:放置项目依赖的地方
public:一般放置一些共用的静态资源，打包上线的时候，public文件夹里面资源原封不动打包到dist文件夹里面
src：程序员源代码文件夹
  assets文件夹：经常放置一些静态资源（图片），assets文件夹里面资源webpack会进行打包为一个模块（js文件夹里面）
  components文件夹:一般放置非路由组件（或者项目共用的组件）
  App.vue 唯一的根组件
  main.js 入口文件【程序最先执行的文件】
  babel.config.js:babel配置文件
  package.json：看到项目描述、项目依赖、项目运行指令
  README.md:项目说明文件

# !!!一些遇到的坑!!!
1.仓库action可以直接操作state，但是这样会是开发者工具检测不到数据变化，仓库actions、mutations中的函数都只接受2个参数
所以传递的数据多的情况下，都装进一个对象中传给第二个参数
2.路由传参 不可以用以前的旧参合并  会有问题
3.所有的请求 都有一个请求头携带token或者uuid  证明用户身份
4.路由鉴权所遇到的坑!!!  -->  history模式下  路由守卫无法从浏览器地址栏输入的url中捕获到from，hash模式则可以正常捕获
5.swiper初始化失败的原因：swiper初始化时，数据未从服务器返回，获取不到相应DOM接点 -->  解决方法：watch配合nextTick
6.document.querySelector无法获取动态id  原因：此选择器只能选择到样式表中已经存在选择器  
  解决方法：使用getElementById代替

  
# src文件夹的别名的设置
因为项目大的时候src（源代码文件夹）：里面目录会很多，找文件不方便，设置src文件夹的别名的好处，找文件会方便一些
创建jsconfig.json文件
{
    "compilerOptions": {
        "baseUrl": "./",
        "paths": {
            "@/*": [
                "src/*"
            ]
        }
    },
    "exclude": [
        "node_modules",
        "dist"
    ]
}

1：安装less less-loader@5
切记less-loader安装5版本的，不要安装在最新版本，安装最新版本less-loader会报错，报的错误setOption函数未定义
2:需要在style标签的身上加上lang="less",不添加样式不生效
     
## 注意事项:
1:项目阶段，左侧菜单目录，只能有项目文件夹
2:联想电脑安装node_modules依赖包的时候，经常丢包。npm install --save axios --force

编程式导航路由跳转到当前路由(参数不变), 多次执行会抛出NavigationDuplicated的警告错误?
注意:编程式导航（push|replace）才会有这种情况的异常，声明式导航是没有这种问题，因为声明式导航内部已经解决这种问题。
这种异常，对于程序没有任何影响的。
为什么会出现这种现象:
由于vue-router最新版本3.5.2，引入了promise，当传递参数多次且重复，会抛出异常，因此出现上面现象,
第一种解决方案：是给push函数，传入相应的成功的回调与失败的回调
第一种解决方案可以暂时解决当前问题，但是以后再用push|replace还是会出现类似现象，
因此需要重写router.prototype.push&&replace；

## axios二次封装
-----API：关于请求相关的（axios）
请求、响应拦截器----nprogress进度条
跨域:如果多次请求协议、域名、端口号有不同的地方，称之为跨域
JSONP、CROS、代理
进度条：nprogress模块实现进度条功能  修改进度条的颜色，修改源码样式.bar类名的

## 组件发送请求的时机
mounted|created:都可以

mounted：模板已经变为真是DOM【只不过没有数据，显示空白】，因为ajax是异步，需要时间的。
created：稍微好那么一丢丢（不算啥）

## 函数防抖与节流

正常：事件触发非常频繁，而且每一次的触发，回调函数都要去执行（如果时间很短，而回调函数内部有计算，那么很可能出现浏览器卡顿）

防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发,只会执行最后一次

节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发

## 优化项目。
防抖与节流
请求次数优化
按需加载:对于loadsh插件，它里面封装的函数功能很多

## 路由的跳转与传参
第一种声明式导航:为什么使用router-link组件的时候，会出现卡顿
router-link是一个组件：相当于VueComponent类的实例对象，一瞬间
new VueComponent很多实例（1000+），很消耗内存，因此导致卡顿。

第二种编程式导航:push|replace

三级分类由于使用router-link的时候，会出现卡顿现象，因此采用编程式导航。

注意1：如果某一个组件在项目当中多个地方出现频繁的使用  就可以把这类组件注册为全局组件。
注意2:项目中共用的全局组件放置于components里面
注意3：全局组件只需要注册一次，就可以在项目当中任意的地方使用，注册全局组件一般是在入口文件注册。
注册全局组件的时候，可以通过组件实例获取相应组件的名字

# 主要业务逻辑
## 首页Home
Home组件挂载完毕 -> 请求三级导航 floor的页面数据 -> 数据返回后存入vuex -> 展示数据

三级联动在home模块正常显示
三级联动在search一会显示、一会隐藏 ---解决方案：通过一个响应式属性控制三级联动显示与隐藏
通过$route让组件区分在那个模块下
如果出现某一个组件要区分当前在哪一个模块中【home、search】，通过$route.meta.xxx路由信息区分
路由跳转的时候，相应的组件会把重新销毁与创建----【keep-alive】

TypeNav三级导航性能优化
home切换到search或者search切换到home，你会发现一件事情，组件在频繁的向服务器发请求，获取三级联动的数据进行展示。
项目中如果频繁的向服务器发请求，很耗费性能，因此需要进行优化。
因为路由跳转的时候，组件会进行销毁的【home组件的created：在向vuex派发action，因此频繁的获取三级联动的数据】
只需要发一次请求，获取到三级联动的数据即可，不需要多次。
最终解决方案：在App组件请求导航数据 APP组件只会挂载一次

mock数据。
注意：因为后台老师没有给我们写好其他接口【老师们特意的：因为就是想练习mock数据】
但是项目中mock数据，你就把他当中真实接口数据用就行。
注意：mock（模拟数据）数据需要使用到mockjs模块，可以帮助我们模拟数据。
注意：mockjs【并非mock.js mock-js】
http://mockjs.com/  官方地址
mock官网一句话：晚上练习的时候，如果网速可以，看看mock的官网，看看语法规则；
生成随机数据，拦截 Ajax 请求
mock官网当中这句话的理解：
模拟的数据一般：对象、数组
{
    'a|1-10':'我爱你'
}
拦截ajax请求：请求发布出去【浏览器会进行拦截：笨想，因为服务器】，只是项目当中本地自己玩耍数据。
第一步:安装依赖包mockjs
第二部：在src文件夹下创建一个文件夹，文件夹mock文件夹。
第三步:准备模拟的数据
把mock数据需要的图片放置于public文件夹中！
比如:listContainer中的轮播图的数据
[
   {id:1,imgUrl:'xxxxxxxxx'}, 
   {id:2,imgUrl:'xxxxxxxxx'}, 
   {id:3,imgUrl:'xxxxxxxxx'}, 
]
第四步：在mock文件夹中创建一个server.js文件
注意：在server.js文件当中对于banner.json||floor.json的数据没有暴露，但是可以在server模块中使用。
对于webpack当中一些模块：图片、json，不需要对外暴露，因为默认就是对外暴露。
第五步:通过mock模块模拟出数据
通过Mock.mock方法进行模拟数据
第六步:回到入口文件，引入serve.js
mock需要的数据|相关mock代码页书写完毕，关于mock当中serve.js需要执行一次，
如果不执行，和你没有书写一样的。
第七步:在API文件夹中创建mockRequest【axios实例：baseURL:'/mock'】
专门获取模拟数据用的axios实例。

swiper基本的使用
8.1:swiper可以在移动端使用？还是PC端使用？
答：swiper移动端可以使用，pc端也可以使用。
8.2:swiper常用于哪些场景？
常用的场景即为轮播图----【carousel:轮播图】
swiper最新版本为7版本的，项目当中使用的是5版本
但是需要注意，home模块很多组件都使用到swiper.css,没必要在每一个组件内部都引入样式一次，
只需要在入口文件引入一次即可。
初始化swiper实例在哪里书写?
初始化swiper实例之前，页面中的节点（结构）务必要有，
对于Vue一个组件而言，mounted[组件挂载完毕：相应的结构不就有了吗]
mounted-->组件挂载完毕
1.4动态效果为什么没有出来？
Swiper需要获取到轮播图的节点DOM，才能给swiper轮播添加动态效果，
因为没有获取到节点。
1.5第一种解决方案，延迟器（不是完美的解决方案）
同学的想法：都不是完美的【错误的想法】
created里面：created执行与mounted执行，时间差可能2ms，白扯
updated里面：如果组件有很多响应式（data），只要有一个属性值发生变化updated还会再次执行，再次初始化实例。
总结：第一种解决方案可以通过延迟器（异步）去解决问题，
但是这种解决方案存在风险（无法确定用户请求到底需要多长时间），因此没办法确定
延迟器时间。
2:Swiper在Vue项目中使用完美解决方案
第一种解决方案问题出现在哪里：v-for,在遍历来自于Vuex（数据:通过ajax向服务器发请求，存在异步）
watch:监听属性，watch可以检测到属性值的变化，当属性值发生变化的时候，可以出发一次。
Vuex当中的仓库数据bannerList（组件在使用）：
bannerList仓库数据有没有发生过变化？
一定是有的：bannerList初始值空数组，当服务器的数据返回以后，它的bannerList存储的属性值会发生变化【变为服务器返回的数据】
组件实例在使用仓库中的bannerList，组件的这个属性bannerList一定是发生过变化，watch可以监听到。
组件实例的一个方法:$nextTick
this.$nextTick(()=>{})
nextTick官网解释:
在下次DOM更新, 循环结束之后,执行延迟回调。在 修改数据之后 立即使用这个方法，获取更新后的DOM。
注意：组件实例的$nextTick方法，在工作当中经常使用，经常结合第三方插件使用，获取更新后的DOM节点
总结:
1:Swiper插件工作的是很常用（今晚把API、基本使用方法）看看
2:组件实例的$nextTick方法。
在下次DOM更新, 循环结束之后,执行延迟回调。在 修改数据之后 立即使用这个方法，获取更新后的DOM
https://www.swiper.com.cn/ 官网地址
1:mockjs模块实现模拟数据
---对于将来实际工作的时候，后台没有准备好接口（服务器没有开发出来），前端工程师可以利用mock技术，
实现模拟数据，将来项目上线（后台真实接口）写好了，替换为真实接口即可。
---对于咱们而言，后台老师确实没有给首页中轮播这部分的接口，mock数据，你可以当中一个真实接口就行了。
上线的时候，对于mock数据对于项目而言没有任何影响。
对于项目而言:真实的接口 /api/xxxx    模拟的数据/mock/xxxx
模拟数据JSON：没有空格，最好使用格式化插件进行格式化。

## search页面业务
search组件挂载 -> 通过路由获取请求的参数 -> 请求search数据 -> 仓库保存 -> 展示数据

开发的三级联动业务，当你点击a标签的时候，会进行路由的跳转，将产品的名字与id传递给search模块----（query）
点击搜索按钮的时候，用户输入进来的关键字，点击按钮的时候会通过params参数传递给search模块-----（params）
路由跳转（home->search）,两个地方，三级联动（typeNav）、Header组件（搜索按钮）

//是搜索模块需要携带给接口的参数
{
  "category1Id": "61",//一级分类的id
  "category2Id": "61",//二级分类的id
  "category3Id": "61",//三级分类的id
  "categoryName": "手机",//产品的名字
  "keyword": "小米",//关键字
  "order": "1:desc",//排序
  "pageNo": 1,//当前第几页
  "pageSize": 10,//每一页需要展示多少条数据
  "props": ["1:1700-2799:价格", "2:6.65-6.74英寸:屏幕尺寸"],//平台属性的选择参数
  "trademark": "4:小米"//品牌参数
}
注意：搜索的接口，需要传递参数，至少是一个空对象（KV没有，但是至少给服务器一个对象）
3)获取search模块数据
4)展示商品列表数据
5)根据用户的搜索条件展示不同的数据。
根据前台传递参数决定的
根据不同条件，展示不同的数据。----->取决于后台返回的数据
1:发请求，获取搜索模块的数据
2:根据用户搜索的条件携带参数给服务器，展示用户搜索的内筒
开发遇见问题:用户条件可以发生多次变化，但是咱们的请求，只是会发一次【mounted中书写的】
请求的性能优化:
发一个请求，需要向服务器携带参数：带100个参数   带1参数  【消耗宽带】
对于给服务器携带的参数：如果数值为undefind，向服务器发请求的时候，参数步携带给服务器的
排序业务
num1:在基础课程当中曾经写过排序业务。
num2:综合与价格按钮，点击谁，谁的背景颜色变为红色。（类名：active）
谁有类这件事情，区分开综合与价格
num3：将来点击综合||价格，还是需要给服务器发请求
【价格升序：把这个信息给服务器传递过去，服务器接收到信息，数据库自动把排序这件事情做了，把排序做好的数据返回给你，你展示即可】
order:服务器需要字段，代表的是排序方式
order这个字段需要的是字符串（可以传递也可以不传递）
1:代表综合
2:代表价格
3:asc代表升序
4:desc代表降序
告诉服务器排序方式有几种情况?
"1:asc" "1:desc"  "2:asc"  "2:desc"
综合与价格箭头
4.1箭头用什么去做【可以选用阿里图标库】  https://www.iconfont.cn/ 
4.2对于综合|价格旁边的箭头【动态显示：时而又，时而没有】，带有类名active，拥有箭头
4.3:根据1、2区分谁有类名（背景）、谁有箭头
    根据asc|desc区分它用哪一个箭头【上、下】
分页器
前端三大件:轮播图、分页、日历。属于前端开发常见三种业务
2.1:为什么很多项目中都采用分页功能
比如电商平台：搜索一个奶粉，奶粉的产品有10000+，一次渲染10000+条数据，可能慢。
数据多的时候，可以选择分页，比如每一次只是展示10
2.2拆分分页组件（静态组件），注册为全局组件，因为其他模块也在使用分页功能。
分页器封装业务分析:
封装分页器组件的时候需要知道哪些条件？
假如你知道条件1、条件2：知道一共多少页 100/3
1:分页器组件需要知道我一共展示多少条数据 ----total【100条数据】
2:每一个需要展示几条数据------pageSize【每一页3条数据】
3:需要知道当前在第几页-------pageNo[当前在第几页]
4:需要知道连续页码数【起始数字、结束数字：连续页码数市场当中一般5、7、9】奇数，对称好看 continues
已经条件: total=【99】  pageSize =【3】  pageNo=6    continues 5 
4 5 6 7 8
已经条件: total=【99】  pageSize =【3】  pageNo= 1    continues 5 
错误:-1 0 1 2 3
正确: 1 2 3 4 5
已经条件: total=【99】  pageSize =【3】  pageNo= 2    continues 5 
错误: 0 1 2 3 4 
正确：1 2 3 4 5 
已经条件: total=【99】  pageSize =【3】  pageNo= 33    continues 5 
错误: 31 32  33 34 35
正确：29 30  31 32 33 
已经条件: total=【99】  pageSize =【3】  pageNo= 32    continues 5 
错误：30 31 32 33 34 
正确: 29 30  31 32 33 
3)分页器封装
3.1进行单元测试
连续页码5: 8   [6,7,8,9,10] 
连续页码7: 8   [5,6,7,8,9,10,11]
连续页码5:  8   [6,7,8,9,10]
连续页码7:  8   [5,6,7,8,9,10,11]
总结:
对于一个分页器:
1)需要知道数据总条数
2)每一个需要展示数据条数
3)知道当前是第几页
4)连续页码数字
5)自定义事件【子给父通信的】

## 商品详情页面--detail
detail组件挂载 -> 通过路由获取请求的参数 -> 请求detail数据 -> 仓库保存 -> 展示数据
放大镜的功能
遮罩层
获取节点（DOM：必须要定位），通过JS动态修改left|top、定位元素才有left、top属性 通过vue的ref获取DOM
ref绑定在元素上获取的是元素DOM  在组件上则是组件实例
商品件数的判断和限制(至少为1，不可以是负数，且不可以是数字以外的东西)

## 加入购物车成功--addCart
组件挂载 -> 请求数据(请求中携带请求头  告诉服务器你的身份) -> 仓库存储 -> 展示
路由跳转
获取购物车的数据进行展示?
举例子:用户是淘宝平台的用户。
为什么目前我们获取不到自己购物车的数据，你没有给我分配一个用户id
张三:奶粉、鞋子、手机
李四:羽绒服
3.1问题1：用哪个技术可以生成用户id【身份】----uuid
3.2问题2:用户身份如何给后台专递过去？
3.3临时身份只需要执行一次
3.4临时身份数据持家化的

## 购物车业务--cart
cart组件挂载 -> 请求购物车的数据(请求中携带请求头  告诉服务器你的身份) -> 仓库保存 -> 展示
购物车静态结构
头部:6
身体:7
静态页面需要删除一些：把每一个产品的第三个li删除
需要修改每一个li的百分比: 
[con1 2 3 4 5 6 7]的百分比
15  35  10 17 10 13
购物车的增删改查
购物车操作的本质是通过接口操作后端服务器中的数据
修改购物车产品数量的时候，需要发请求的，通知服务器产品最新的个数【服务器需要保存】，

## 登录注册业务
收集表单数据 -> 按钮携带表单数据发送请求验证 -> 正确跳转路由(错误提示失败)
在样式当中也可以使用@,在样式当中使用@，前面加上~

获取验证码
注册业务【手机号、验证码、登录密码】，点击注册按钮的时候，需要把这些信息给服务器传递过去
手机号:11位
验证码：4-6
登录密码：英文字母、数字、首字母大写等等
登录业务
点击登录按钮的时候，需要把手机号、密码需要携带给服务器，服务器需要判断，你是不是我的用户【注册过的】
如果是用户登录成功，进行登录，如果用户登录失败给一个提示即可。
token【令牌：字符串，服务器下发给用户的身份凭证】

用户登录以后获取用户信息进行展示
登录成功以后，服务器会返回token【存储于vuex当中】，如果想获取用户信息
还需要再发请求【用户信息】，携带token给服务器。 
api/user/passport/auth/getUserInfo 获取用户信息的接口
为什么刷新页面，用户信息就消失
用户刷新页面，用户信息消失没了获取不到，因为token没有携带给服务器。
本地存储持久化存储token
为什么去别的模块【非home模块】获取用户信息失败？
因为你去别的模块根本没有发请求获取用户信息，没办法展示用户信了

怎么解决:
每一个组件都在mounted里面发起获取用户信息，进行展示（可以太麻烦）
APP组件挂载后请求用户数据
仓库读取浏览器本地存储(有token表示已登录，使用loaclStorage的token请求用户信息)
没有则限制部分模块展示
残留的问题：用户在home模块刷新的时候，用户信息一直在展示（mounted执行的时候在向服务器发请求、获取用户信息展示）
home->search[用户信息刷新数据就没了，因为在search模块当中根本没有发请求获取用户信息]
search-detail[根本没有获取用户信息进行展示]

退出登录
发请求，需要通知服务器，把现在用户身份token【销毁】
清除仓库数据+本地存储数据【都需要清理】

路由权限鉴定
路由规则中meta字段配置meta.auth存在说明需要鉴权

导航守卫判断路由权限
全局守卫：
前置守卫：路由跳转之前可以做一些事情。
后置守卫：路由跳转已经完成在执行。

路由独享守卫：
针对某一个路由的守卫
组件内守卫：
也是负责某一个路由守卫

身份凭证
TOKEN身份为大
UUID生成的临时省份
用户（注册与登录）token【正式身份】

## 交易业务
组件挂载 -> 请求数据 -> 展示
账号:13700000000
密码:111111

1.1获取用户地址信息、获取用户购物车清单信息
//用户地址信息
/api/user/userAddress/auth/findUserAddressList
//商品清单接口
/api/order/auth/trade

2)展示商品清单数据

3)提交订单业务

当用户点击提交订单按钮的时候，需要发请求的
提交订单的请求地址:/api/order/auth/submitOrder?tradeNo={tradeNo}

前台：需要告诉服务器：谁买的、买的啥、买几个、 支付多少钱、留言信息...
后台：订单号，这笔交易的一个标识符【支付的】

axios({url:'xxx',methods:'post',data:{a:1})

微信支付、支付宝支付等等
交易编码（服务器：字符串hash）
收件人名字
收件人手机号
收件的地址
买家留言信息
支付产品

4)获取支付信息进行展示

5)element-plus

第一步：项目中安装element-plus组件库
第二步：在入口文件引入element-plus组件库
1：全部引入【不采用：因为项目中只是用到一个组件，没必要全都引入进来】
2：按需引入【按照开发需求引入相应的组件，并非全部组件引入】
第三步：按需引入，安装相应的插件
npm install babel-plugin-component -D
文档中说的.babelrc文件，即为babel.config.js文件
修改完babel.config.js配置文件以后，项目重启
第四步：按照需求引入相应的组件即可

6)支付业务【微信支付】
 this.$alert('<strong>这是 <i>HTML</i> 片段</strong>', 'HTML 片段', {dangerouslyUseHTMLString: true});
6.2使用messageBox显示弹框
6.3展示二维码----qrcode插件
通过qrCode.toDataUrl方法，将字符串转换为加密的在线二维码链接，通过图片进行展示。
moment.js
swiper.js
nprogress.js
qrcode.js

GET|POST：短轮询，请求发一次，服务器响应一次

第一种做法:前端开启定时器，一直找服务器要用户支付信息【定时器】

第二种做法:项目务必要上线 + 和后台紧密配合
当用户支付成功以后，需要后台重定向到项目某一个路由中，将支付情况通过URL参数形式传给前端，
前端获取到服务器返回的参数，就可以判断了。

## 我的订单列表路由搭建
组件挂载 -> 重定向到默认二级路由 -> 二级路由组件挂载后请求数据展示

前置守卫：在路由跳转之前，进行判断
后置守卫:路由都已经跳转完毕才执行。

未登录的情况:
全局守卫:只要的项目当中任何某一个路由发生变化，就会出发。
项目守卫使用:一般有用前置全局守卫

用户登录:
用户未登录：点击购物车的结算按钮->交易页面【没有登录:去不了】
  未登录不能调到支付页面
  未登录不能调到支付成功页面
  未登录不能去个人中心【都不知道你是谁：展示谁的个人中心啊】

路由独享守卫
路由独享守卫：需要在配置路由的地方使用
导航守卫:全局守卫->项目当中有任何路由变化【a->b,b->d】触发。
        路由独享守卫：专门负责某一个路由

用户登陆了:
去交易页面:从购物车才能跳转到交易页面。

next():你本来想去哪里，我就放行，你就去完事了。

next('/login'):执行守卫放行到执行的路由。

next(false):路由跳转的时候，从哪里来回那里去。

组件内守卫---->一般很少用【全局 + 路由独享守卫】
组件内守卫：也是专门负责某一个路由【并非负责全部路由】，写法和路由独享守卫有区别？
组件内守卫需要书写在组件内部

beforeRouteEnter
beforeRouteUpdate (2.2 新增)
beforeRouteLeave

## 项目细节优化
路由懒加载

图片懒加载
vue-lazyload:图片懒加载

表单验证
element-plus 自带表单验证
vee-validate插件：Vue官方提供的一个表单验证的插件 这个插件很难用

使用步骤：
1：安装vee-valadite，别安装最新版本@2
2：在plugins文件夹中创建一个validate.js[专门注册vee-valadite]
3:注册插件
4：注册插件的时候，用中文，以及需要验证的字段【用中文显示提示形式】
5：在入口文件需要引入执行一次
6:使用vee-valadiate插件

vee-validate 基本使用

第一步：插件安装与引入
cnpm i vee-validate@2 --save  安装的插件安装2版本的

import VeeValidate from 'vee-validate'
import zh_CN from 'vee-validate/dist/locale/zh_CN'   // 引入中文 message
Vue.use(VeeValidate)

第二步：提示信息
VeeValidate.Validator.localize('zh_CN', {
messages: {
...zh_CN.messages,
is: (field) => `${field}必须与密码相同` // 修改内置规则的 message，让确认密码和密码相同
},
attributes: { // 给校验的 field 属性名映射中文名称
phone: '手机号',
code: '验证码',
password:'密码',
password1:'确认密码',
isCheck:'协议'
}
})

第三步：基本使用
<input
          placeholder="请输入你的手机号"
          v-model="phone"
          name="phone"
          v-validate="{ required: true, regex: /^1\d{10}$/ }"
          :class="{ invalid: errors.has('phone') }"
        />
<span class="error-msg">{{ errors.first("phone") }}</span>

const success = await this.$validator.validateAll(); //全部表单验证
//自定义校验规则
//定义协议必须打勾同意
VeeValidate.Validator.extend('agree', {
validate: value => {
return value
},
getMessage: field => field + '必须同意'
})